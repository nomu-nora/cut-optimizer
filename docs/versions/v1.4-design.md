# v1.4 設計書 - 手動調整機能

**プロジェクト**: 取り数最適化システム v1.4
**作成日**: 2025年12月16日
**v1.4.1実装完了日**: 2025年12月19日
**v1.4.2実装完了日**: 2025年12月22日
**ステータス**: v1.4.1 ✅ 完了、v1.4.2 ✅ 完了、v1.4.3以降は予定
**機能**: 配置結果の手動調整機能

---

## 📋 目次

1. [概要](#概要)
2. [背景と目的](#背景と目的)
3. [要件定義](#要件定義)
4. [データ構造](#データ構造)
5. [アルゴリズム設計](#アルゴリズム設計)
6. [UI/UX設計](#uiux設計)
7. [実装計画](#実装計画)
8. [テスト計画](#テスト計画)
9. [将来の拡張](#将来の拡張)
10. [参考資料](#参考資料)

---

## 1. 概要

### 1.1 機能概要

**手動調整機能**は、自動配置計算の結果に満足できない場合に、ユーザーが製品の配置を手動で調整できる機能です。

### 1.2 主な特徴

- ✅ SVG配置図上でドラッグ&ドロップによる製品移動
- ✅ 近隣製品の角へのスマートスナップ（刃幅考慮）
- ✅ 仮置き場を介したパターン間移動
- ✅ 製品数の整合性維持
- ✅ 編集内容の適用・破棄機能

### 1.3 期待される効果

- **柔軟性向上**: 自動配置の微調整が可能
- **ユーザー満足度**: 細かい要望に対応
- **作業効率化**: 計算結果を元に手動で最適化
- **実務対応**: 実際の作業現場の制約に対応

---

## 2. 背景と目的

### 2.1 背景

現在のシステム（v1.3.1）では、自動配置計算のみを提供しています。しかし、実際の現場では：

- 自動配置結果が作業手順に合わない場合がある
- 特定の製品を特定の位置に配置したい要望がある
- 配置を微調整するために再計算すると時間がかかる
- 複数のパターン間で製品を移動したい場合がある

### 2.2 目的

手動調整機能を提供することで：

1. **柔軟性**: 自動配置を起点に微調整が可能
2. **効率化**: 再計算不要で素早く調整
3. **実用性**: 現場の制約や要望に対応
4. **ユーザビリティ**: 直感的な操作で配置を変更

---

## 3. 要件定義

### 3.1 機能要件

#### FR-1: 編集モード

- **FR-1.1**: 「編集モード」ボタンで編集モードに入る
- **FR-1.2**: 編集モード中は計算結果のコピーを操作
- **FR-1.3**: 「適用」ボタンで変更を確定
- **FR-1.4**: 「すべて破棄」ボタンで変更を取り消し
- **FR-1.5**: 編集モード中はパターン選択が可能

#### FR-2: ドラッグ&ドロップ

- **FR-2.1**: SVG配置図上で製品をドラッグできる
- **FR-2.2**: ドラッグ中は製品の位置がリアルタイムで更新
- **FR-2.3**: 元板の境界内に配置を制限
- **FR-2.4**: 他の製品と重ならないよう衝突検出
- **FR-2.5**: 無効な位置の場合は視覚的にフィードバック（赤枠）

#### FR-3: スマートスナップ

- **FR-3.1**: 近隣製品の角に自動スナップ（閾値: 10mm）
- **FR-3.2**: 刃幅を考慮したスナップポイント生成
- **FR-3.3**: スナップ時に破線ガイドを表示
- **FR-3.4**: スナップのON/OFF切り替えが可能
- **FR-3.5**: タッチデバイスではスナップ閾値を拡大（20mm）

#### FR-4: 仮置き場（パターン間移動）

- **FR-4.1**: 製品をクリックすると仮置き場に移動
- **FR-4.2**: 仮置き場の製品一覧を表示
- **FR-4.3**: パターンを切り替えても仮置き場の製品は保持
- **FR-4.4**: 仮置き場の製品をクリックして選択
- **FR-4.5**: 配置図上をクリックして選択製品を配置
- **FR-4.6**: 製品総数が登録数と一致することを検証

#### FR-5: パターン数処理

- **FR-5.1**: パターン数が2以上の場合にダイアログを表示
- **FR-5.2**: 「この1枚のみ編集（新パターン作成）」を選択可能
- **FR-5.3**: 「全○枚に適用」を選択可能
- **FR-5.4**: 選択に応じてパターン数を更新

### 3.2 非機能要件

#### NFR-1: パフォーマンス

- ドラッグ操作は60fps以上でスムーズに動作
- 100個以上の製品があってもスナップ判定は遅延なし（空間ハッシュ使用）

#### NFR-2: ユーザビリティ

- ドラッグ操作は直感的で分かりやすい
- 無効な操作は視覚的にフィードバック
- モバイル・タッチデバイスでも操作可能

#### NFR-3: 互換性

- v1.3.1の既存機能に影響を与えない
- 編集モードを使わない場合は従来通りの動作

### 3.3 制約事項

#### C-1: 回転機能

- v1.4では製品の回転状態を維持（回転操作は未実装）
- 回転ハンドルはv1.5以降で追加予定

#### C-2: アンドゥ/リドゥ

- v1.4では「すべて破棄」のみ実装
- 詳細なアンドゥ/リドゥスタックはv1.5以降で追加予定

#### C-3: マルチ選択

- v1.4では単一製品の操作のみ
- 複数製品の同時選択・移動はv1.5以降で追加予定

---

## 4. データ構造

### 4.1 型定義

#### EditableResult（編集可能な結果）

```typescript
/**
 * 編集可能な計算結果
 * Copy-on-Writeパターンで元の結果を保持
 */
export interface EditableResult extends CalculationResult {
  /** 編集済みフラグ */
  isEdited: boolean

  /** 元の計算結果（破棄時に復元） */
  originalResult: CalculationResult

  /** 変更履歴（将来のアンドゥ/リドゥ用） */
  modifications: Modification[]
}
```

#### StagingArea（仮置き場）

```typescript
/**
 * パターン間移動のための仮置き場
 */
export interface StagingArea {
  /** 仮置き場の製品リスト */
  products: Placement[]

  /** 製品の元パターンIDマッピング */
  sourcePatternIds: Map<string, string>
}
```

#### SnapPoint（スナップポイント）

```typescript
/**
 * スナップ候補ポイント
 */
export interface SnapPoint {
  /** X座標（mm） */
  x: number

  /** Y座標（mm） */
  y: number

  /** ポイントタイプ */
  type: 'corner' | 'edge'

  /** 元製品ID（デバッグ用） */
  sourceItemId?: string
}
```

#### Modification（変更履歴）

```typescript
/**
 * 変更履歴（将来のアンドゥ/リドゥ用）
 */
export interface Modification {
  /** 変更タイプ */
  type: 'move' | 'add' | 'remove'

  /** 対象パターンID */
  patternId: string

  /** 対象製品 */
  placement: Placement

  /** 変更前の座標（move時） */
  previousPosition?: { x: number; y: number }

  /** 変更後の座標（move時） */
  newPosition?: { x: number; y: number }

  /** タイムスタンプ */
  timestamp: Date
}
```

### 4.2 データフロー

```
計算結果（CalculationResult）
    ↓
[編集モード開始]
    ↓
EditableResult作成（Deep Copy）
+ StagingArea初期化
    ↓
ユーザー操作
  ├─ ドラッグ → placement.x, placement.yを更新
  ├─ クリック → 仮置き場に移動
  ├─ パターン切替 → selectedPattern変更
  └─ 仮置き場から配置 → pattern.placements追加
    ↓
製品数検証（配置数 = 登録数）
    ↓
[適用] → result = editableResult
[破棄] → result = originalResult
```

---

## 5. アルゴリズム設計

### 5.1 スナップポイント生成

#### 概要

各製品の4つの角と、刃幅を考慮したオフセット位置をスナップポイントとして生成します。

#### アルゴリズム

```typescript
/**
 * パターン内の全製品からスナップポイントを生成
 * @param placements 配置リスト
 * @param cutConfig 切断設定
 * @returns スナップポイント配列
 */
function generateSnapPoints(placements: Placement[], cutConfig: CutConfig): SnapPoint[] {
  const points: SnapPoint[] = []
  const gap = cutConfig.cutWidth

  for (const p of placements) {
    // 4つの角
    points.push(
      { x: p.x, y: p.y, type: 'corner', sourceItemId: p.item.id },
      { x: p.x + p.width, y: p.y, type: 'corner', sourceItemId: p.item.id },
      { x: p.x, y: p.y + p.height, type: 'corner', sourceItemId: p.item.id },
      { x: p.x + p.width, y: p.y + p.height, type: 'corner', sourceItemId: p.item.id }
    )

    // 刃幅オフセット（8ポイント）
    points.push(
      { x: p.x - gap, y: p.y, type: 'corner' },
      { x: p.x + p.width + gap, y: p.y, type: 'corner' },
      { x: p.x - gap, y: p.y + p.height, type: 'corner' },
      { x: p.x + p.width + gap, y: p.y + p.height, type: 'corner' },
      { x: p.x, y: p.y - gap, type: 'corner' },
      { x: p.x + p.width, y: p.y - gap, type: 'corner' },
      { x: p.x, y: p.y + p.height + gap, type: 'corner' },
      { x: p.x + p.width, y: p.y + p.height + gap, type: 'corner' }
    )
  }

  return points
}
```

#### 空間ハッシュによる高速化

製品数が多い場合、全スナップポイントを線形探索すると遅くなるため、空間ハッシュを使用してO(1)で最近接ポイントを検索します。

```typescript
/**
 * 空間ハッシュ用のグリッドクラス
 */
class SpatialHashGrid {
  private cellSize: number
  private grid: Map<string, SnapPoint[]>

  constructor(cellSize: number = 100) {
    this.cellSize = cellSize
    this.grid = new Map()
  }

  /**
   * ポイントを追加
   */
  addPoint(point: SnapPoint): void {
    const key = this.getKey(point.x, point.y)
    if (!this.grid.has(key)) {
      this.grid.set(key, [])
    }
    this.grid.get(key)!.push(point)
  }

  /**
   * 指定座標の近くのポイントを検索
   */
  findNearby(x: number, y: number, threshold: number): SnapPoint | null {
    const cellsToCheck = Math.ceil(threshold / this.cellSize)
    let nearest: SnapPoint | null = null
    let minDist = threshold

    for (let dx = -cellsToCheck; dx <= cellsToCheck; dx++) {
      for (let dy = -cellsToCheck; dy <= cellsToCheck; dy++) {
        const key = this.getKey(x + dx * this.cellSize, y + dy * this.cellSize)
        const points = this.grid.get(key)
        if (!points) continue

        for (const point of points) {
          const dist = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2))
          if (dist < minDist) {
            minDist = dist
            nearest = point
          }
        }
      }
    }

    return nearest
  }

  private getKey(x: number, y: number): string {
    const cellX = Math.floor(x / this.cellSize)
    const cellY = Math.floor(y / this.cellSize)
    return `${cellX},${cellY}`
  }
}
```

### 5.2 衝突検出

#### AABB衝突検出（刃幅考慮）

```typescript
/**
 * 製品同士の衝突をチェック（刃幅を考慮）
 * @param placement チェック対象の配置
 * @param otherPlacements 他の配置リスト
 * @param cutConfig 切断設定
 * @returns 衝突している場合true
 */
function checkCollision(
  placement: Placement,
  otherPlacements: Placement[],
  cutConfig: CutConfig
): boolean {
  const gap = cutConfig.cutWidth

  for (const other of otherPlacements) {
    // 自分自身はスキップ
    if (other.item.id === placement.item.id) continue

    // AABB衝突判定（刃幅のギャップを含む）
    const collides = !(
      placement.x + placement.width + gap <= other.x ||
      placement.x >= other.x + other.width + gap ||
      placement.y + placement.height + gap <= other.y ||
      placement.y >= other.y + other.height + gap
    )

    if (collides) return true
  }

  return false
}

/**
 * 元板境界チェック（余白を考慮）
 */
function checkBounds(
  placement: Placement,
  plateConfig: PlateConfig,
  cutConfig: CutConfig
): boolean {
  const margin = cutConfig.margin

  return (
    placement.x >= margin &&
    placement.y >= margin &&
    placement.x + placement.width <= plateConfig.width - margin &&
    placement.y + placement.height <= plateConfig.height - margin
  )
}
```

### 5.3 製品数検証

#### 整合性チェック

```typescript
/**
 * 編集後の製品数が登録数と一致することを検証
 * @param editableResult 編集中の結果
 * @param stagingArea 仮置き場
 * @param originalItems 元の製品リスト
 * @returns 検証結果
 */
function validateQuantities(
  editableResult: EditableResult,
  stagingArea: StagingArea,
  originalItems: Item[]
): { valid: boolean; errors: string[] } {
  const placedCounts = new Map<string, number>()

  // 全パターンの配置をカウント
  for (const pattern of editableResult.patterns) {
    for (const placement of pattern.placements) {
      const itemId = placement.item.id
      const count = pattern.count // パターン数を掛ける
      placedCounts.set(itemId, (placedCounts.get(itemId) || 0) + count)
    }
  }

  // 仮置き場の製品をカウント
  for (const product of stagingArea.products) {
    const itemId = product.item.id
    placedCounts.set(itemId, (placedCounts.get(itemId) || 0) + 1)
  }

  // 検証
  const errors: string[] = []
  for (const item of originalItems) {
    const placed = placedCounts.get(item.id) || 0
    const required = item.quantity

    if (placed !== required) {
      errors.push(`${item.name}: 配置数${placed} ≠ 登録数${required}`)
    }
  }

  return { valid: errors.length === 0, errors }
}
```

### 5.4 座標変換

#### SVG座標とスクリーン座標の変換

```typescript
/**
 * SVG座標変換ユーティリティ
 */
class SVGCoordinateTransform {
  /**
   * スクリーン座標をSVG座標に変換
   * @param screenX スクリーンX座標
   * @param screenY スクリーンY座標
   * @param svgElement SVG要素
   * @returns SVG座標
   */
  static screenToSVG(
    screenX: number,
    screenY: number,
    svgElement: SVGSVGElement
  ): { x: number; y: number } {
    const pt = svgElement.createSVGPoint()
    pt.x = screenX
    pt.y = screenY

    const svgPt = pt.matrixTransform(svgElement.getScreenCTM()!.inverse())

    return { x: svgPt.x, y: svgPt.y }
  }

  /**
   * SVG座標をスクリーン座標に変換
   */
  static svgToScreen(
    svgX: number,
    svgY: number,
    svgElement: SVGSVGElement
  ): { x: number; y: number } {
    const pt = svgElement.createSVGPoint()
    pt.x = svgX
    pt.y = svgY

    const screenPt = pt.matrixTransform(svgElement.getScreenCTM()!)

    return { x: screenPt.x, y: screenPt.y }
  }
}
```

---

## 6. UI/UX設計

### 6.1 編集モードツールバー

#### 配置

配置図の上部に表示

```
┌─────────────────────────────────────────────────────┐
│ 計算結果                                             │
├─────────────────────────────────────────────────────┤
│                                                     │
│  [編集モード] [スナップ: ON]                         │  ← v1.4で追加
│  [✓ 適用] [✕ すべて破棄]                            │
│                                                     │
└─────────────────────────────────────────────────────┘
```

#### ボタン仕様

| ボタン     | 状態   | 動作                              |
| ---------- | ------ | --------------------------------- |
| 編集モード | 通常時 | 編集モードに入る（Copy-on-Write） |
| 編集モード | 編集中 | （押せない）                      |
| 適用       | 編集中 | 変更を確定してビューモードに戻る  |
| すべて破棄 | 編集中 | 変更を破棄してビューモードに戻る  |
| スナップ   | 編集中 | スナップのON/OFF切り替え          |

### 6.2 仮置き場UI

#### 配置

配置図の右側にサイドパネルとして表示

```
┌─────────────┬───────────────────────┐
│             │ 仮置き場 (2個)        │
│             ├───────────────────────┤
│             │                       │
│             │ ┌───────────────────┐ │
│  配置図     │ │ 製品A (300×200)   │ │
│             │ │ クリックで選択     │ │
│             │ └───────────────────┘ │
│             │                       │
│             │ ┌───────────────────┐ │
│             │ │ 製品B (400×300)   │ │
│             │ │ クリックで選択     │ │
│             │ └───────────────────┘ │
│             │                       │
│             │ ※配置したい製品を     │
│             │   クリックしてから     │
│             │   配置図をクリック     │
│             │                       │
└─────────────┴───────────────────────┘
```

#### 特徴

- 仮置き場の製品は色付きカードで表示
- クリックすると選択状態（青枠）になる
- 選択中はカーソルが「配置モード」に変化
- 製品名・サイズ・色を表示

### 6.3 配置図のインタラクション

#### ドラッグ中の表示状態

| 状態                   | 表示                         |
| ---------------------- | ---------------------------- |
| 通常                   | 製品は元の色、不透明度0.8    |
| ホバー                 | カーソルが移動アイコンに変化 |
| ドラッグ中             | 製品は半透明（不透明度0.6）  |
| ドラッグ中（有効位置） | 青枠でハイライト             |
| ドラッグ中（無効位置） | 赤枠でハイライト + 赤背景    |
| スナップ中             | 破線ガイドを表示             |

#### スナップガイド表示

```
    │ (破線)
    │
────┼────  ← X軸またはY軸の破線ガイド
    │
    ┌─────┐
    │製品 │ ← スナップ中の製品
    └─────┘
```

#### 配置フロー

1. **ドラッグ操作**:
   - 製品をマウスダウン
   - ドラッグ中は座標をリアルタイム更新
   - スナップポイントに近づくとスナップ
   - マウスアップで位置を確定

2. **仮置き場への移動**:
   - 製品をクリック
   - 確認なしで仮置き場に移動
   - パターンから削除され、歩留まり再計算

3. **仮置き場からの配置**:
   - 仮置き場の製品をクリックして選択
   - 配置図の空いている場所をクリック
   - 衝突・境界チェックを実行
   - 有効な場合のみ配置、無効ならアラート

### 6.4 パターン数ダイアログ

#### 表示条件

パターン数が2以上の場合、編集モードに入る前に表示

#### デザイン

```
┌────────────────────────────────────────┐
│ パターンAは3枚使用されています          │
├────────────────────────────────────────┤
│                                        │
│ 編集内容を適用する範囲を選択してください │
│                                        │
│ ○ この1枚のみ編集（新パターンを作成）   │
│   → パターンAを2枚、新パターンを1枚    │
│                                        │
│ ○ 全3枚に適用                          │
│   → パターンAの3枚すべてに反映        │
│                                        │
│         [キャンセル]  [OK]             │
│                                        │
└────────────────────────────────────────┘
```

#### 動作

- 「この1枚のみ」選択時:
  - 元パターンのcountを-1
  - 新しいパターンIDを生成（パターンZ等）
  - 新パターンのcountは1

- 「全○枚に適用」選択時:
  - 元パターンをそのまま編集
  - countは変更なし

### 6.5 レスポンシブ対応

#### デスクトップ（1024px以上）

- 配置図とサイドバーを横並び表示
- スナップ閾値: 10mm

#### タブレット（768px - 1023px）

- 配置図とサイドバーを横並び表示（幅を調整）
- スナップ閾値: 15mm

#### モバイル（767px以下）

- 配置図を全幅表示
- 仮置き場を下部に折りたたみ表示
- スナップ閾値: 20mm

---

## 7. 実装計画

### 7.1 Phase 1: 基盤（3-4時間）

#### 新規作成ファイル

**`src/types/editing.ts`** - 型定義

```typescript
export interface EditableResult { ... }
export interface StagingArea { ... }
export interface SnapPoint { ... }
export interface Modification { ... }
```

**`src/components/editing/EditModeToolbar.tsx`** - ツールバー

- 編集モード切り替えボタン
- 適用・破棄ボタン
- スナップ切り替えトグル

**`src/components/editing/StagingArea.tsx`** - 仮置き場UI

- 製品リスト表示
- 選択状態管理
- クリックで選択

#### 更新ファイル

**`src/app/page.tsx`** - 状態管理

```typescript
const [editMode, setEditMode] = useState(false)
const [editableResult, setEditableResult] = useState<EditableResult | null>(null)
const [stagingArea, setStagingArea] = useState<StagingArea>({
  products: [],
  sourcePatternIds: new Map(),
})
const [selectedPlacement, setSelectedPlacement] = useState<Placement | null>(null)
```

**`src/types/index.ts`** - エクスポート追加

**タスク**:

1. EditableResult, StagingArea, SnapPoint型定義
2. 編集モード状態追加
3. enterEditMode()関数（Deep Copy）
4. exitEditMode()関数
5. 基本ツールバー構築
6. 仮置き場コンポーネント構築

### 7.2 Phase 2: ドラッグ&ドロップコア（4-5時間）

#### 新規作成ファイル

**`src/components/editing/DraggableProduct.tsx`** - ドラッグ可能な製品

```typescript
interface DraggableProductProps {
  placement: Placement
  onDragStart: (placement: Placement) => void
  onDrag: (x: number, y: number) => void
  onDragEnd: (x: number, y: number) => void
  isInvalid?: boolean
  isSelected?: boolean
}
```

**`src/lib/utils/svg-coordinates.ts`** - 座標変換

```typescript
export class SVGCoordinateTransform {
  static screenToSVG(...)
  static svgToScreen(...)
}
```

**`src/lib/validation/placement-validation.ts`** - 検証

```typescript
export function checkCollision(...)
export function checkBounds(...)
```

**タスク**:

1. Pointer Eventハンドラ実装（onPointerDown/Move/Up）
2. SVG座標変換ロジック
3. 元板境界制約
4. 衝突検出アルゴリズム
5. 視覚状態（hover, dragging, invalid）
6. ドラッグ終了時の配置更新

### 7.3 Phase 3: スマートスナップ（3-4時間）

#### 新規作成ファイル

**`src/lib/editing/snap-points.ts`** - スナップロジック

```typescript
export function generateSnapPoints(...)
export class SpatialHashGrid { ... }
export function findNearestSnapPoint(...)
```

**`src/components/editing/SnapGuide.tsx`** - スナップガイド

```typescript
interface SnapGuideProps {
  snapPoint: SnapPoint | null
  draggedPlacement: Placement | null
}
```

**タスク**:

1. スナップポイント生成（角 + cutWidthオフセット）
2. 空間ハッシュによる高速検索
3. ドラッグ中の最近接スナップポイント検索
4. スナップガイド描画（破線）
5. スナップアニメーション（150ms ease-out）
6. スナップON/OFF切り替え

### 7.4 Phase 4: 編集可能配置図統合（2-3時間）

#### 新規作成ファイル

**`src/components/results/EditablePlacementDiagram.tsx`** - メインコンポーネント

- DraggableProduct + SnapGuide + 背景レンダリングを統合
- 配置更新ハンドラ
- パターン歩留まり再計算
- 製品クリック→仮置き場移動

#### 更新ファイル

**`src/app/page.tsx`**

- 条件付きレンダリング（view vs edit mode）
- EditablePlacementDiagramの統合

**タスク**:

1. DraggableProduct + SnapGuide統合
2. 配置更新処理
3. パターン歩留まり再計算
4. ビューモード/編集モード切り替え
5. パターン選択統合

### 7.5 Phase 5: 仮置き場とパターン間移動（4-5時間）

#### 新規作成ファイル

**`src/lib/validation/quantity-validation.ts`** - 製品数検証

```typescript
export function validateQuantities(...)
```

**`src/components/editing/PatternCountDialog.tsx`** - パターン数ダイアログ

```typescript
interface PatternCountDialogProps {
  patternId: string
  count: number
  onConfirm: (choice: 'single' | 'all') => void
  onCancel: () => void
}
```

#### 更新ファイル

**`src/components/editing/EditablePlacementDiagram.tsx`**

- 製品選択（クリック）
- 仮置き場への移動

**`src/components/editing/StagingArea.tsx`**

- 仮置き場からの配置

**`src/app/page.tsx`**

- パターン切り替え（仮置き場保持）

**タスク**:

1. クリック→仮置き場移動
2. 仮置き場の製品リスト表示
3. パターン切り替え（ドロップダウン/タブ）
4. 仮置き場の製品をクリック→選択
5. 空スペースをクリック→配置
6. 製品総数検証（配置数 = 登録数）
7. パターン数ダイアログ（count > 1時）
8. 仮置き場 → パターン → 仮置き場フロー

### 7.6 Phase 6: 仕上げとテスト（3-4時間）

**タスク**:

1. **視覚的フィードバック改善**
   - ドラッグ中のゴーストアウトライン
   - 無効配置のオーバーレイ（赤色）
   - スナップ成功時のアニメーション

2. **キーボードショートカット**
   - ESC: 選択/ドラッグをキャンセル
   - Shift: 一時的にスナップを無効化

3. **モバイル/タッチ調整**
   - スナップ閾値拡大（20mm）
   - タッチフレンドリーなボタンサイズ

4. **ユニットテスト**
   - スナップポイント生成
   - 衝突検出
   - 製品数検証

5. **統合テスト**
   - ドラッグフロー
   - 仮置き場フロー

6. **手動テスト**
   - 各ブラウザで動作確認

### 7.7 合計所要時間

**推定**: 19-25時間（1-2週間）

---

## 8. テスト計画

### 8.1 ユニットテスト

#### スナップポイント生成

```typescript
describe('generateSnapPoints', () => {
  it('should generate corner points for each placement', () => {
    const placements = [
      { x: 100, y: 100, width: 200, height: 150, ... }
    ]
    const cutConfig = { cutWidth: 4, margin: 20 }

    const points = generateSnapPoints(placements, cutConfig)

    // 4 corners + 8 offset points = 12 points
    expect(points.length).toBe(12)
    expect(points).toContainEqual({ x: 100, y: 100, type: 'corner', ... })
    expect(points).toContainEqual({ x: 96, y: 100, type: 'corner' }) // cutWidth offset
  })

  it('should handle multiple placements', () => {
    const placements = [
      { x: 100, y: 100, width: 200, height: 150, ... },
      { x: 400, y: 200, width: 150, height: 100, ... }
    ]
    const cutConfig = { cutWidth: 4, margin: 20 }

    const points = generateSnapPoints(placements, cutConfig)

    expect(points.length).toBe(24) // 12 points per placement
  })
})
```

#### 衝突検出

```typescript
describe('checkCollision', () => {
  it('should detect collision with gap', () => {
    const placement = { x: 100, y: 100, width: 100, height: 100, item: { id: '1' } }
    const others = [{ x: 200, y: 100, width: 100, height: 100, item: { id: '2' } }]
    const cutConfig = { cutWidth: 4, margin: 20 }

    // Too close (gap = 4mm)
    expect(checkCollision(placement, others, cutConfig)).toBe(true)
  })

  it('should not detect collision with proper gap', () => {
    const placement = { x: 100, y: 100, width: 100, height: 100, item: { id: '1' } }
    const others = [{ x: 205, y: 100, width: 100, height: 100, item: { id: '2' } }]
    const cutConfig = { cutWidth: 4, margin: 20 }

    // Proper gap (5mm > 4mm)
    expect(checkCollision(placement, others, cutConfig)).toBe(false)
  })
})
```

#### 製品数検証

```typescript
describe('validateQuantities', () => {
  it('should validate matching quantities', () => {
    const editableResult = {
      patterns: [
        {
          placements: [{ item: { id: '1', name: '製品A' } }],
          count: 2,
        },
      ],
    }
    const stagingArea = { products: [], sourcePatternIds: new Map() }
    const originalItems = [{ id: '1', name: '製品A', quantity: 2 }]

    const result = validateQuantities(editableResult, stagingArea, originalItems)

    expect(result.valid).toBe(true)
    expect(result.errors).toHaveLength(0)
  })

  it('should detect quantity mismatch', () => {
    const editableResult = {
      patterns: [
        {
          placements: [{ item: { id: '1', name: '製品A' } }],
          count: 1,
        },
      ],
    }
    const stagingArea = { products: [], sourcePatternIds: new Map() }
    const originalItems = [{ id: '1', name: '製品A', quantity: 3 }]

    const result = validateQuantities(editableResult, stagingArea, originalItems)

    expect(result.valid).toBe(false)
    expect(result.errors).toContain('製品A: 配置数1 ≠ 登録数3')
  })

  it('should include staging area in count', () => {
    const editableResult = {
      patterns: [
        {
          placements: [{ item: { id: '1', name: '製品A' } }],
          count: 2,
        },
      ],
    }
    const stagingArea = {
      products: [{ item: { id: '1', name: '製品A' } }],
      sourcePatternIds: new Map(),
    }
    const originalItems = [{ id: '1', name: '製品A', quantity: 3 }]

    const result = validateQuantities(editableResult, stagingArea, originalItems)

    expect(result.valid).toBe(true) // 2 + 1 = 3
  })
})
```

### 8.2 統合テスト

#### ドラッグ&ドロップフロー

```typescript
describe('Drag and Drop Flow', () => {
  it('should allow dragging within bounds', () => {
    // 1. 編集モードに入る
    enterEditMode()

    // 2. 製品をドラッグ
    const product = getPlacementById('product-1')
    dragProduct(product, { x: 200, y: 200 })

    // 3. 配置が更新されている
    expect(product.x).toBe(200)
    expect(product.y).toBe(200)
  })

  it('should prevent invalid placement', () => {
    enterEditMode()

    const product = getPlacementById('product-1')
    const originalX = product.x

    // 衝突する位置にドラッグ
    dragProduct(product, { x: 100, y: 100 }) // 他製品と重なる

    // 配置が元に戻る
    expect(product.x).toBe(originalX)
  })

  it('should snap to nearby corner', () => {
    enterEditMode()

    const product = getPlacementById('product-1')

    // スナップポイント付近にドラッグ（102mm、実際のスナップは100mm）
    dragProduct(product, { x: 102, y: 100 })

    // スナップされる
    expect(product.x).toBe(100)
    expect(product.y).toBe(100)
  })
})
```

#### 仮置き場フロー

```typescript
describe('Staging Area Flow', () => {
  it('should move product to staging', () => {
    enterEditMode()
    selectPattern('A')

    const product = getPlacementById('product-1')
    clickProduct(product)

    // 仮置き場に移動
    expect(getStagingArea().products).toContainEqual(product)
    expect(getPattern('A').placements).not.toContainEqual(product)
  })

  it('should place product from staging to another pattern', () => {
    enterEditMode()
    selectPattern('A')

    // 製品を仮置き場に移動
    const product = getPlacementById('product-1')
    clickProduct(product)

    // パターンBに切り替え
    selectPattern('B')

    // 仮置き場から製品を選択
    clickStagingProduct(product)

    // 配置図上をクリック
    clickDiagram({ x: 200, y: 200 })

    // パターンBに配置される
    expect(getPattern('B').placements).toContainEqual(
      expect.objectContaining({
        item: product.item,
        x: 200,
        y: 200,
      })
    )
    expect(getStagingArea().products).not.toContainEqual(product)
  })

  it('should validate total quantities', () => {
    enterEditMode()

    // 製品を仮置き場に移動
    const product = getPlacementById('product-1')
    clickProduct(product)

    // 適用を試みる
    const result = validateAndApply()

    // 仮置き場に製品が残っているのでエラー
    expect(result.valid).toBe(false)
    expect(result.errors).toContain(expect.stringContaining('配置数'))
  })
})
```

### 8.3 UI/UXテスト

#### 手動テストシナリオ

**編集モード**

- [ ] 「編集モード」ボタンで編集モードに入れる
- [ ] 編集中は「適用」「破棄」ボタンが表示される
- [ ] 「適用」で変更が確定される
- [ ] 「すべて破棄」で変更が取り消される

**ドラッグ&ドロップ**

- [ ] 製品をドラッグできる
- [ ] ドラッグ中は半透明になる
- [ ] 有効な位置では青枠が表示される
- [ ] 無効な位置では赤枠が表示される
- [ ] 元板の外にはドラッグできない
- [ ] 他の製品と重ならない

**スナップ**

- [ ] 近くの角に自動スナップする
- [ ] スナップ時に破線ガイドが表示される
- [ ] スナップOFF時はスナップしない
- [ ] タッチデバイスでスナップ閾値が大きい

**仮置き場**

- [ ] 製品クリックで仮置き場に移動
- [ ] 仮置き場の製品一覧が表示される
- [ ] パターン切り替えで仮置き場は保持される
- [ ] 仮置き場の製品をクリックして選択できる
- [ ] 配置図クリックで選択製品を配置できる
- [ ] 無効な位置には配置できない

**パターン数ダイアログ**

- [ ] パターン数2以上でダイアログ表示
- [ ] 「この1枚のみ」選択で新パターン作成
- [ ] 「全○枚に適用」選択で全てに反映

**製品数検証**

- [ ] 適用時に製品数が検証される
- [ ] 不一致の場合エラーメッセージが表示される
- [ ] 仮置き場に製品が残っていると適用できない

---

## 9. 将来の拡張

### 9.1 v1.5以降で検討する機能

#### アンドゥ/リドゥ

```typescript
interface UndoRedoStack {
  past: Modification[][]
  future: Modification[][]
}

// Ctrl+Z: Undo
// Ctrl+Shift+Z: Redo
```

#### 回転ハンドル

- ダブルクリックで90度回転
- 角のハンドルをドラッグして回転
- 回転角度を自由に指定（0-360度）

#### マルチ選択

- Ctrl+クリックで複数製品選択
- 選択製品を一括移動
- 選択製品を一括削除

#### コピー&ペースト

- Ctrl+C: 選択製品をコピー
- Ctrl+V: 貼り付け
- パターン間でもコピー可能

#### キーボード微調整

- 矢印キー: 1mm単位で移動
- Shift+矢印: 10mm単位で移動
- スナップ無効でも微調整可能

#### 履歴タイムライン

- 全変更履歴を時系列で表示
- 任意のポイントに戻る
- 変更の差分を視覚化

### 9.2 v1.6以降で検討する機能

#### 配置パターンのテンプレート保存

- よく使う配置をテンプレートとして保存
- テンプレートを読み込んで適用
- テンプレートのインポート/エクスポート

#### AIによる配置提案

- ユーザーの編集履歴を学習
- より良い配置を提案
- 提案を受け入れるかユーザーが選択

---

## 10. 参考資料

### 10.1 関連ドキュメント

- [v1.1設計書](./v1.1-design.md) - Maximal Rectangles実装
- [v1.2設計書](./v1.2-design.md) - 最適化強化（GA・グリッド配置）
- [v1.3設計書](./v1.3-design.md) - 端材利用機能
- [アーキテクチャ設計書](../architecture.md)
- [アルゴリズム詳細仕様書](../algorithm-details.md)

### 10.2 技術参考

#### Pointer Events API

- [MDN - Pointer Events](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events)
- SVGとネイティブに統合
- マウス・タッチの両方に対応

#### SVG座標変換

- [MDN - getScreenCTM()](https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getScreenCTM)
- スクリーン座標とSVG座標の変換

#### 空間ハッシュ

- グリッドベースの空間分割
- O(1)での近傍検索
- 大量オブジェクトのパフォーマンス最適化

### 10.3 用語集

| 用語          | 説明                                         |
| ------------- | -------------------------------------------- |
| 編集モード    | 配置結果を手動で編集できるモード             |
| 仮置き場      | パターン間移動のための一時保管場所           |
| スナップ      | 近くの基準点に自動的に吸着すること           |
| Copy-on-Write | 編集時に元データをコピーして変更する手法     |
| AABB衝突検出  | Axis-Aligned Bounding Box による矩形衝突判定 |
| 空間ハッシュ  | 座標空間をグリッドに分割して高速検索         |

---

**作成**: 2025-12-16
**作成者**: Claude Sonnet 4.5

🤖 Generated with [Claude Code](https://claude.com/claude-code)
