# v1.5 最適化アルゴリズム改善

**バージョン**: v1.5 → v1.5.1
**ステータス**: ✅ 実装完了
**v1.5実装完了日**: 2025-12-19
**v1.5.1実装完了日**: 2025-12-22
**最終更新**: 2025-12-22

## 概要

歩留まり優先アルゴリズムを改善し、「最後のパターンを除いた全パターンで85%以上の歩留まりを目指す」機能を実装。
Phase 1（新メトリクス表示）とPhase 2（アルゴリズムレベル改善）の両方が完了。

## 背景

### 現状の課題

#### 歩留まり優先モード

- 最後のパターンのみ余りを詰め込む形になっている
- 最後のパターンを除く他のパターンは82%超えの歩留まりを達成
- 製品サイズを考えるとほぼ使い切っている充填率だが、理想は85%以上

#### あまりスペース優先モード

- 端材活用の意識が弱い
- 歩留まりとのバランスが取りにくい

## 改善方針

### 1. 歩留まり優先アルゴリズムの改善

#### 基本コンセプト

**「最後のパターンを除いた全パターンで85%以上の歩留まりを目指す」**

#### 戦略

```
パターン1: 歩留まり85%以上
パターン2: 歩留まり85%以上
パターン3: 歩留まり85%以上
...
パターンN-1: 歩留まり85%以上
パターンN（最後）: 歩留まり低くても可（調整用）
```

#### 最後のパターンの扱い

- **役割**: 調整用パターン
- **歩留まり**: 低下を許容
- **余りスペースの活用**: 次のカッティングで端材として再利用
- **考え方**: 最後の1枚の余りのみを端材利用に回す

#### 期待される効果

- ほとんどのパターンで高い歩留まり（85%以上）を実現
- 最後のパターンで柔軟に調整可能
- 端材として再利用可能な形状を意識した余りスペース

### 2. あまりスペース優先アルゴリズムの改善

#### 基本コンセプト

**「最初から端材活用を前提とした配置設計」**

#### 戦略

- 全パターンで端材として使いやすい形状を意識
- 余りスペースを最大限再利用可能な形状で残す
- 歩留まりも可能な限り高く保つ

#### 期待される効果

- 端材の再利用率向上
- 長期的な材料コスト削減
- より実用的な配置結果

### 3. 2つのアルゴリズムの明確な違い

| 項目               | 歩留まり優先                | あまりスペース優先       |
| ------------------ | --------------------------- | ------------------------ |
| **基本戦略**       | とにかく歩留まり重視        | 端材活用を最初から意識   |
| **目標歩留まり**   | 最後以外85%以上             | バランスを取りつつ最大化 |
| **最後のパターン** | 調整用（低歩留まり許容）    | 端材として使いやすい形状 |
| **全体的な考え方** | 最後の1枚の余りのみ端材利用 | 全パターンで端材を意識   |
| **適用シーン**     | 高い歩留まりが最優先        | 端材の再利用が重要       |

## 実装方針（案）

### Phase 1: 歩留まり計算ロジックの改善

#### 1. 最後のパターンを除外した歩留まり計算

```typescript
function calculateYieldExcludingLast(patterns: PatternGroup[]): number {
  if (patterns.length <= 1) {
    return patterns[0]?.yield || 0
  }

  const patternsExcludingLast = patterns.slice(0, -1)
  const totalYield = patternsExcludingLast.reduce((sum, p) => sum + p.yield * p.count, 0)
  const totalCount = patternsExcludingLast.reduce((sum, p) => sum + p.count, 0)

  return totalCount > 0 ? totalYield / totalCount : 0
}
```

#### 2. 歩留まり目標の設定

```typescript
interface OptimizationConfig {
  goal: OptimizationGoal
  targetYield?: number // 歩留まり優先時の目標値（デフォルト: 85%）
  allowLastPatternLowYield?: boolean // 最後のパターンの低歩留まりを許容（デフォルト: true）
}
```

### Phase 2: 配置アルゴリズムの改善

#### 歩留まり優先モードの改善

1. **パターン生成時に85%以上を目指す**
   - 配置候補を評価する際、歩留まりを重視
   - 85%未満になる配置は優先度を下げる

2. **最後のパターンの特別扱い**
   - 最後のパターンのみ歩留まり制約を緩和
   - 余りスペースを端材として使いやすい形状に調整

3. **パターン数の最適化**
   - 85%以上を維持できるパターン数を動的に調整
   - 必要に応じてパターン数を増やす

#### あまりスペース優先モードの改善

1. **端材として使える形状の評価**
   - 矩形性の高い余りスペースを優先
   - 最小サイズ制約を考慮

2. **配置順序の最適化**
   - 大きい製品から配置
   - 端材として使いやすい形状を残す配置を優先

### Phase 3: UI改善

#### 結果表示の改善

```typescript
interface OptimizationResult {
  // 既存フィールド
  patterns: PatternGroup[]
  averageYield: number

  // 追加フィールド
  yieldExcludingLast: number // 最後を除いた歩留まり
  lastPatternYield: number // 最後のパターンの歩留まり
  meetsYieldTarget: boolean // 目標歩留まりを達成したか
}
```

#### サマリー表示の拡張

```
歩留まり情報
├── 全体平均: 78.5%
├── 最後を除く平均: 86.2% ✓（目標85%以上達成）
└── 最後のパターン: 45.3%（調整用）
```

## 実装優先度

### High Priority (v1.5)

- [ ] 歩留まり計算ロジックの改善
- [ ] 最後のパターンを除いた歩留まり表示
- [ ] 基本的な配置アルゴリズムの改善

### Medium Priority (v1.6)

- [ ] 端材形状の評価ロジック
- [ ] 配置順序の最適化
- [ ] より詳細なUI表示

### Low Priority (v1.7+)

- [ ] 機械学習を使った配置最適化
- [ ] 複数パターンの同時最適化
- [ ] 端材データベース連携

## 参考情報

### 現状の最適化目標

- `yield-priority`: 歩留まり優先
- `remaining-space`: あまりスペース優先

### 関連ファイル

- `src/lib/algorithm/guillotine.ts` - メインアルゴリズム
- `src/lib/algorithm/placement.ts` - 配置ロジック
- `src/lib/algorithm/sort.ts` - ソートロジック
- `src/lib/utils/yield-calculator.ts` - 歩留まり計算

## 実装状況（2025-12-19完了）

### ✅ Phase 1: 新メトリクス追加と表示（完了）

**実装内容:**

- `calculateYieldExcludingLast()` - 最後のパターンを除いた平均歩留まり計算
- `getLastPatternYield()` - 最後のパターンの歩留まり取得
- `meetsYieldTarget()` - 85%目標達成判定
- `ResultSummary.tsx` - 歩留まり詳細表示セクション追加

**修正ファイル:**

- `src/types/result.ts` - 4つの新フィールド追加
- `src/lib/algorithm/yield.ts` - 3つの新関数実装
- `src/lib/algorithm/maximal-rectangles.ts` - 新メトリクス計算統合
- `src/lib/algorithm/guillotine.ts` - 新メトリクス計算統合
- `src/components/results/ResultSummary.tsx` - UI表示追加

### ✅ Phase 2: アルゴリズムレベル改善（完了）

**実装内容:**

#### Step 1: 全ヒューリスティック比較

- すべてのヒューリスティックを試行してスコアリング
- 歩留まり優先時は `yieldExcludingLast` を重視
- 85%達成時のボーナススコア追加

#### Step 2: 目標達成判定の強化

- `evaluatePlacementProgress()` - 配置中の進捗評価
- 適応的な戦略切り替え（aggressive/balanced/conservative）
- 戦略に応じた minGridSize 調整

#### Step 3: 適応的グリッド生成

- 4次元スコアリング（使用率、アスペクト比、アイテム数、余白品質）
- 戦略別の重み調整

#### Step 4: スペース使用率最適化

- Best-fit度、位置スコア、面積スコアの総合評価
- 戦略別の空き矩形選択

**修正ファイル:**

- `src/lib/algorithm/maximal-rectangles.ts` - 4ステップ全て実装
- `src/lib/algorithm/offcut-placement.ts` - 新フィールド伝播
- `src/lib/algorithm/__tests__/maximal-rectangles-enhanced.test.ts` - 包括的テスト追加（新規）

### テスト結果

- ✅ 全66テストパス（既存49 + Phase 2の17テスト）
- ✅ TypeScript型チェック成功
- ✅ 実行時間: 0.556秒
- ✅ 後方互換性維持

### 期待される効果

- 最後以外のパターンで85%以上の歩留まり達成
- 最後のパターンは調整用として柔軟に対応
- ユーザーへの分かりやすいフィードバック（「最適」or「改善可能」表示）
- 端材として再利用可能な余りスペースの生成

---

## 追加実装: 2段階最適化アルゴリズム（2025-12-20完了）

### 概要

Stage 1で初期配置を行い、Stage 2でパターン再編成を行う2段階アプローチを実装。
歩留まり優先モードとスペース優先モードの両方で、より最適な配置を探索する。

### ✅ 実装完了

#### 新規ファイル

1. **`src/lib/algorithm/two-stage-optimizer.ts`**
   - 2段階最適化のメインエントリーポイント
   - Stage 1: `calculateMaximalRectangles`で初期配置
   - Stage 2: 目標に応じて`reorganizeForYield`または`reorganizeForSpace`を呼び出し
   - ユーティリティ関数: `extractAllItemsFromPatterns`, `rebuildCalculationResult`

2. **`src/lib/algorithm/reorganize-yield.ts`**
   - 歩留まり優先モードの再編成ロジック
   - N-1枚の歩留まりを最大化
   - 複数回試行（MAX_ATTEMPTS=3）して最良解を選択
   - 製品総数と元板枚数を維持（絶対制約）
   - 最後のパターンは調整用として残り全製品を配置

3. **`src/lib/algorithm/reorganize-space.ts`**
   - スペース優先モードの再編成ロジック
   - 端材サイズを自動検出（元板の分数サイズ + 一般的な規格サイズ）
   - 端材品質スコアリング（目標サイズとの近さ、形状品質、サイズ）
   - 複数回試行（MAX_ATTEMPTS=5）して端材品質を最大化
   - 目標使用率70-80%（端材を残すため）

4. **`src/types/optimization.ts`**
   - 型定義: `OffcutSize`, `SwapCandidate`, `ReorganizationResult`, `ImprovementEntry`

5. **`src/lib/algorithm/__tests__/two-stage-optimizer.test.ts`**
   - 包括的なテストスイート（8テスト）
   - 両モードの動作確認
   - 全製品配置の検証
   - ユーティリティ関数のテスト

### 主要機能

#### 歩留まり優先モード

- **目標**: N-1枚の平均歩留まりを最大化
- **戦略**:
  - 初回試行: 面積降順の貪欲法
  - 2回目以降: ランダムシャッフルで多様性確保
  - 各試行で全製品を再配分
  - 同一パターンを自動グループ化

#### スペース優先モード

- **目標**: 端材品質の最大化
- **戦略**:
  - 目標端材サイズを自動検出
  - 使用率を意図的に70-80%に抑える（端材を残す）
  - 端材の形状品質を評価（矩形性、サイズ、目標との近さ）
  - 複数回試行で最良の端材配置を探索

### テスト結果

- ✅ **全59テストパス**（既存51 + 新規8テスト）
- ✅ **TypeScript型チェック成功**
- ✅ **後方互換性維持**

### 技術的特徴

1. **製品数・元板枚数の保証**
   - Stage 1で決定された元板枚数を維持
   - 全製品が必ず配置される（スキップなし）

2. **多様な試行戦略**
   - 貪欲法とランダムサーチのハイブリッド
   - 初期配置からの改善を保証

3. **パターングループ化**
   - 同一配置のパターンを自動検出して統合
   - `count`フィールドで重複表現

4. **柔軟な評価関数**
   - 歩留まり優先: `yieldExcludingLast`を最大化
   - スペース優先: 端材品質スコアを最大化

### 使用方法

```typescript
import { calculateWithTwoStageOptimization } from '@/lib/algorithm/two-stage-optimizer'

// 歩留まり優先
const result = calculateWithTwoStageOptimization(plateConfig, cutConfig, items, 'yield', false)

// スペース優先
const result = calculateWithTwoStageOptimization(
  plateConfig,
  cutConfig,
  items,
  'remaining-space',
  false
)
```

### 今後の拡張可能性

- [ ] 試行回数の動的調整（製品数・パターン数に応じて）
- [ ] より高度な端材形状評価（実際の`freeSpaces`を使用）
- [ ] パターン間での製品スワップ最適化
- [ ] 並列試行による高速化
- [ ] ユーザー指定の目標端材サイズ
