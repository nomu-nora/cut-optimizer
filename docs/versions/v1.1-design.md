# v1.1 設計書: ギロチンカット精度向上

**バージョン**: v1.1
**作成日**: 2025年12月4日
**目的**: 現在のギロチンカットアルゴリズムの精度向上
**優先度**: 高

---

## 📌 概要

v1.0で実装したギロチンカットアルゴリズムは、基本的な配置は可能だが、歩留まりが低く実用性に欠ける。
v1.1では、Genetic Algorithm（遺伝的アルゴリズム）を用いて配置戦略を最適化し、精度を向上させる。

---

## 🎯 目標

### 主目標

- **歩留まり率の向上**: 5-10%の改善を目指す
- **計算時間**: 10秒以内に抑える
- **既存インターフェース維持**: UIの変更なし、アルゴリズム部分のみ改善

### 副目標

- より良い配置パターンの発見
- 端材の形状改善（次に使いやすい形に）
- 手動調整が少なくなるレベルの精度

---

## 🔧 技術アプローチ

### Genetic Algorithm (GA) の適用

#### 1. 個体（Individual）の定義

配置戦略の組み合わせを個体として扱う：

```typescript
interface Individual {
  sortStrategy: SortStrategy // ソート戦略
  rotationStrategy: RotationStrategy // 回転戦略
  fitness: number // 適応度（歩留まり率）
  result: CalculationResult // 計算結果
}

type SortStrategy = 'area' | 'width' | 'height' | 'long-edge' | 'short-edge'
type RotationStrategy = 'max-space' | 'fit-space' | 'prefer-rotate' | 'no-rotate'
```

#### 2. 適応度関数（Fitness Function）

個体の良さを評価する基準：

```typescript
function calculateFitness(result: CalculationResult): number {
  // 重み付けスコア
  const plateScore = 100 - result.totalPlates // 枚数が少ないほど高得点
  const yieldScore = result.averageYield // 歩留まりが高いほど高得点

  // 総合スコア（枚数を優先）
  return plateScore * 2 + yieldScore
}
```

#### 3. 選択（Selection）

適応度の高い個体を選択：

```typescript
function selection(population: Individual[]): Individual[] {
  // トーナメント選択（上位50%を選択）
  const sorted = population.sort((a, b) => b.fitness - a.fitness)
  return sorted.slice(0, Math.ceil(population.length / 2))
}
```

#### 4. 交叉（Crossover）

2つの親から子を生成：

```typescript
function crossover(parent1: Individual, parent2: Individual): Individual {
  // 単純な1点交叉
  return {
    sortStrategy: Math.random() > 0.5 ? parent1.sortStrategy : parent2.sortStrategy,
    rotationStrategy: Math.random() > 0.5 ? parent1.rotationStrategy : parent2.rotationStrategy,
  }
}
```

#### 5. 突然変異（Mutation）

ランダムに戦略を変更：

```typescript
function mutation(individual: Individual, mutationRate: number = 0.1): Individual {
  if (Math.random() < mutationRate) {
    // ソート戦略をランダムに変更
    const sortStrategies: SortStrategy[] = ['area', 'width', 'height', 'long-edge', 'short-edge']
    individual.sortStrategy = sortStrategies[Math.floor(Math.random() * sortStrategies.length)]
  }

  if (Math.random() < mutationRate) {
    // 回転戦略をランダムに変更
    const rotationStrategies: RotationStrategy[] = [
      'max-space',
      'fit-space',
      'prefer-rotate',
      'no-rotate',
    ]
    individual.rotationStrategy =
      rotationStrategies[Math.floor(Math.random() * rotationStrategies.length)]
  }

  return individual
}
```

#### 6. メインループ

```typescript
function geneticAlgorithm(
  plateConfig: PlateConfig,
  cutConfig: CutConfig,
  items: Item[],
  options: GAOptions = {}
): CalculationResult {
  const {
    populationSize = 20, // 個体数
    generations = 10, // 世代数
    mutationRate = 0.1, // 突然変異率
  } = options

  // 初期集団の生成
  let population = initializePopulation(populationSize, plateConfig, cutConfig, items)

  // 世代交代
  for (let gen = 0; gen < generations; gen++) {
    // 適応度の評価
    population = evaluatePopulation(population)

    // 選択
    const selected = selection(population)

    // 交叉と突然変異で新世代を生成
    const newPopulation: Individual[] = []

    while (newPopulation.length < populationSize) {
      const parent1 = selected[Math.floor(Math.random() * selected.length)]
      const parent2 = selected[Math.floor(Math.random() * selected.length)]

      let child = crossover(parent1, parent2)
      child = mutation(child, mutationRate)

      newPopulation.push(child)
    }

    // エリート保存（最良の個体を次世代に残す）
    newPopulation[0] = population[0]

    population = newPopulation
  }

  // 最良の個体を返す
  return population.sort((a, b) => b.fitness - a.fitness)[0].result
}
```

---

## 📊 パラメータ調整

### 推奨パラメータ

| パラメータ     | 値  | 理由                           |
| -------------- | --- | ------------------------------ |
| 個体数         | 20  | 多様性と計算時間のバランス     |
| 世代数         | 10  | 十分な進化と計算時間のバランス |
| 突然変異率     | 0.1 | 局所最適からの脱出             |
| エリート保存数 | 1   | 最良解を確実に保持             |

### 計算時間の見積もり

```
1パターンの計算時間: 約0.5秒（製品数30個の場合）
個体数: 20
世代数: 10

合計: 0.5秒 × 20個体 × 10世代 = 100秒

→ 並列化で改善可能（Web Workers使用）
→ 早期終了条件で改善可能（十分良い解が見つかったら終了）
```

---

## 🚀 実装計画

### フェーズ1: GAエンジンの実装（2-3時間）

**ファイル**: `src/lib/algorithm/genetic.ts`

```typescript
;-initializePopulation() - // 初期集団生成
  evaluatePopulation() - // 適応度評価
  selection() - // 選択
  crossover() - // 交叉
  mutation() - // 突然変異
  geneticAlgorithm() // メインループ
```

### フェーズ2: guillotine.tsとの統合（1時間）

`calculate()` 関数を拡張：

```typescript
export function calculate(
  plateConfig: PlateConfig,
  cutConfig: CutConfig,
  items: Item[],
  useGA: boolean = true // GAを使うかどうか
): CalculationResult {
  if (useGA) {
    return geneticAlgorithm(plateConfig, cutConfig, items)
  } else {
    // 既存の複数パターン試行
    return calculateMultipleStrategies(plateConfig, cutConfig, items)
  }
}
```

### フェーズ3: UIの改善（1時間）

計算中の進捗表示：

```tsx
<div className="calculating">
  <Spinner />
  <p>
    最適な配置を探索中... (世代 {currentGen}/{totalGen})
  </p>
  <Progress value={(currentGen / totalGen) * 100} />
</div>
```

### フェーズ4: テストとチューニング（2時間）

- 実データでの検証
- パラメータ調整
- パフォーマンス最適化

---

## ✅ 成功基準

### 必須条件

- [ ] 歩留まり率が現在より5%以上向上
- [ ] 計算時間が10秒以内
- [ ] 元板枚数が現在より減少
- [ ] 既存のテストが全てパス

### 理想条件

- [ ] 歩留まり率が10%以上向上
- [ ] 計算時間が5秒以内
- [ ] 端材の形状が改善（目視確認）

---

## 🔄 代替案

### 案1: Simulated Annealing（焼きなまし法）

GAの代わりにSimulated Annealingを使用：

**利点**:

- 実装がシンプル
- パラメータ調整が少ない

**欠点**:

- 多様性がGAより低い
- 局所最適に陥りやすい

### 案2: Beam Search

複数の候補を並行して探索：

**利点**:

- 確実に良い解を見つける
- 実装が比較的簡単

**欠点**:

- 計算時間が増える
- メモリ使用量が多い

---

## 📝 次のステップ（v1.2への橋渡し）

v1.1で改善されても、ギロチンカットの制約は残る。
v1.2では、Maximal Rectanglesアルゴリズムに移行し、根本的な改善を図る。

---

## 🔗 関連ドキュメント

- [v1.2設計書: Maximal Rectanglesアルゴリズム](./v1.2-design.md)
- [アルゴリズム詳細仕様書](./algorithm-details.md)
- [ロードマップ](../ROADMAP.md)
