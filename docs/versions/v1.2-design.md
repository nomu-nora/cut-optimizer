# v1.2 設計書: Maximal Rectanglesアルゴリズム

**バージョン**: v1.2
**作成日**: 2025年12月4日
**目的**: ギロチンカット制約を外し、実用レベルの精度を達成
**優先度**: 最高
**理由**: これがないと実家で使えない

---

## 📌 概要

v1.0/v1.1のギロチンカットは、直線的な切断のみを許可するため、L字型などの複雑な空きスペースを活用できない。
v1.2では、**Maximal Rectanglesアルゴリズム**を導入し、より柔軟な配置を実現する。

---

## 🎯 目標

### 主目標

- **歩留まり率の大幅改善**: 15-25%の改善を目指す
- **実用レベルの精度**: 手作業と同等かそれ以上
- **実家で使えるレベル**: 実際の業務で活用可能

### 副目標

- L字型などの複雑な空きスペースの活用
- 端材の最小化
- より現実的な配置パターン

---

## 🔧 Maximal Rectanglesアルゴリズムとは

### 基本概念

ギロチンカットとの違い：

```
【ギロチンカット】
- 製品を配置 → 直線で分割
- 空きスペースは常に矩形のまま
- L字型のスペースは活用できない

┌─────────────┐
│  A  │       │
├─────┤  空き │  ← 縦に直線分割
│  B  │       │
└─────────────┘

【Maximal Rectangles】
- 製品を配置 → 重なる矩形を分割して新しい矩形を生成
- 複数の矩形が重なり合う状態を許容
- L字型のスペースも複数の矩形で表現

┌─────────────┐
│  A  │┌─────┐│
├─────┘│ 空き││  ← 複数の矩形で
│  B   │     ││     表現可能
└──────┴─────┘│
```

### アルゴリズムの流れ

1. **初期状態**: 元板全体を1つの空き矩形として登録
2. **配置**: 製品を空き矩形に配置
3. **分割**: 配置した製品と重なる空き矩形を分割
4. **更新**: 新しい空き矩形のリストを生成
5. **繰り返し**: 全ての製品を配置するまで繰り返す

---

## 💻 技術詳細

### データ構造

```typescript
/**
 * 空き矩形（Free Rectangle）
 */
interface FreeRectangle {
  x: number // 左上X座標
  y: number // 左上Y座標
  width: number // 幅
  height: number // 高さ
}

/**
 * 配置済み製品
 */
interface PlacedItem {
  item: Item
  x: number
  y: number
  width: number // 配置時の幅（回転考慮）
  height: number // 配置時の高さ（回転考慮）
  rotated: boolean
}

/**
 * 元板
 */
interface Plate {
  id: string
  placements: PlacedItem[]
  freeRectangles: FreeRectangle[] // 複数の空き矩形を管理
  yield: number
}
```

### コアアルゴリズム

#### 1. 配置可能な矩形を探す

```typescript
function findFreeRectangle(
  item: Item,
  freeRectangles: FreeRectangle[]
): { rect: FreeRectangle; rotated: boolean } | null {
  // 各空き矩形に配置を試みる
  for (const rect of freeRectangles) {
    // 回転なしで配置可能か
    if (item.width <= rect.width && item.height <= rect.height) {
      return { rect, rotated: false }
    }

    // 回転ありで配置可能か
    if (item.height <= rect.width && item.width <= rect.height) {
      return { rect, rotated: true }
    }
  }

  return null
}
```

#### 2. 製品を配置して矩形を分割

```typescript
function placeItemAndSplit(plate: Plate, item: Item, rect: FreeRectangle, rotated: boolean): void {
  const width = rotated ? item.height : item.width
  const height = rotated ? item.width : item.height

  // 配置情報を記録
  plate.placements.push({
    item,
    x: rect.x,
    y: rect.y,
    width,
    height,
    rotated,
  })

  // 新しい空き矩形のリストを生成
  const newFreeRectangles: FreeRectangle[] = []

  // 各既存の空き矩形について、配置した製品と重なる部分を分割
  for (const free of plate.freeRectangles) {
    // 重なりがない場合はそのまま残す
    if (!isOverlapping(free, rect.x, rect.y, width, height)) {
      newFreeRectangles.push(free)
      continue
    }

    // 重なる場合、最大4つの新しい矩形に分割
    const splits = splitRectangle(free, rect.x, rect.y, width, height)
    newFreeRectangles.push(...splits)
  }

  // 重複する矩形を削除（重要な最適化）
  plate.freeRectangles = removeDuplicates(newFreeRectangles)
}
```

#### 3. 矩形の分割

製品を配置した領域と重なる空き矩形を最大4つの新しい矩形に分割：

```typescript
function splitRectangle(
  rect: FreeRectangle,
  placedX: number,
  placedY: number,
  placedWidth: number,
  placedHeight: number
): FreeRectangle[] {
  const splits: FreeRectangle[] = []

  // 右側の空きスペース
  if (placedX + placedWidth < rect.x + rect.width) {
    splits.push({
      x: placedX + placedWidth,
      y: rect.y,
      width: rect.x + rect.width - (placedX + placedWidth),
      height: rect.height,
    })
  }

  // 下側の空きスペース
  if (placedY + placedHeight < rect.y + rect.height) {
    splits.push({
      x: rect.x,
      y: placedY + placedHeight,
      width: rect.width,
      height: rect.y + rect.height - (placedY + placedHeight),
    })
  }

  // 左側の空きスペース
  if (placedX > rect.x) {
    splits.push({
      x: rect.x,
      y: rect.y,
      width: placedX - rect.x,
      height: rect.height,
    })
  }

  // 上側の空きスペース
  if (placedY > rect.y) {
    splits.push({
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: placedY - rect.y,
    })
  }

  return splits
}
```

#### 4. 重複する矩形の削除

他の矩形に完全に含まれる矩形を削除：

```typescript
function removeDuplicates(rectangles: FreeRectangle[]): FreeRectangle[] {
  const result: FreeRectangle[] = []

  for (let i = 0; i < rectangles.length; i++) {
    const rect = rectangles[i]
    let isContained = false

    // 他の矩形に完全に含まれているかチェック
    for (let j = 0; j < rectangles.length; j++) {
      if (i === j) continue

      const other = rectangles[j]

      if (
        rect.x >= other.x &&
        rect.y >= other.y &&
        rect.x + rect.width <= other.x + other.width &&
        rect.y + rect.height <= other.y + other.height
      ) {
        isContained = true
        break
      }
    }

    if (!isContained) {
      result.push(rect)
    }
  }

  return result
}
```

### 配置ヒューリスティック

どの空き矩形に配置するかを決める戦略：

```typescript
type PlacementHeuristic =
  | 'best-short-side-fit' // 短辺の余りが最小
  | 'best-long-side-fit' // 長辺の余りが最小
  | 'best-area-fit' // 面積の余りが最小
  | 'bottom-left' // 左下優先
  | 'contact-point' // 他の製品との接触面積が最大

function selectBestRectangle(
  item: Item,
  freeRectangles: FreeRectangle[],
  heuristic: PlacementHeuristic
): FreeRectangle | null {
  let best: FreeRectangle | null = null
  let bestScore = Infinity

  for (const rect of freeRectangles) {
    const score = calculateScore(item, rect, heuristic)

    if (score < bestScore) {
      bestScore = score
      best = rect
    }
  }

  return best
}
```

---

## 🚀 実装計画

### フェーズ1: コアアルゴリズムの実装（4時間）

**ファイル**: `src/lib/algorithm/maximal-rectangles.ts`

```typescript
;-FreeRectangle型の定義 -
  findFreeRectangle() - // 配置可能な矩形を探す
  splitRectangle() - // 矩形を分割
  removeDuplicates() - // 重複削除
  placeItemAndSplit() - // 配置と分割
  calculateMaximalRectangles() // メイン関数
```

### フェーズ2: ヒューリスティックの実装（2時間）

```typescript
;-selectBestRectangle() - // 最適な矩形を選択
  calculateScore() // スコア計算
```

### フェーズ3: guillotine.tsとの統合（1時間）

`calculate()` 関数を拡張：

```typescript
export function calculate(
  plateConfig: PlateConfig,
  cutConfig: CutConfig,
  items: Item[],
  algorithm: 'guillotine' | 'maximal-rectangles' = 'maximal-rectangles'
): CalculationResult {
  if (algorithm === 'maximal-rectangles') {
    return calculateMaximalRectangles(plateConfig, cutConfig, items)
  } else {
    return calculateGuillotine(plateConfig, cutConfig, items)
  }
}
```

### フェーズ4: テストとデバッグ（3時間）

- 既存テストの更新
- 新しいテストケースの追加
- 実データでの検証
- バグ修正

---

## ✅ 成功基準

### 必須条件

- [ ] 歩留まり率がv1.1より15%以上向上
- [ ] 元板枚数がv1.1より減少
- [ ] 計算時間が30秒以内
- [ ] 全てのテストがパス
- [ ] 実家のデータで実用レベルの精度

### 理想条件

- [ ] 歩留まり率が90%以上
- [ ] 計算時間が10秒以内
- [ ] 手作業と同等かそれ以上の精度

---

## 🎨 UI/UX への影響

### 設定画面の追加

アルゴリズム選択オプション：

```tsx
<select value={algorithm} onChange={(e) => setAlgorithm(e.target.value)}>
  <option value="guillotine">ギロチンカット（高速）</option>
  <option value="maximal-rectangles">Maximal Rectangles（高精度）</option>
</select>
```

### 計算中の表示

```tsx
<div className="calculating">
  <Spinner />
  <p>高精度な配置を計算中...</p>
  <p className="text-sm text-gray-500">Maximal Rectanglesアルゴリズムで最適化しています</p>
</div>
```

---

## ⚠️ 注意事項とリスク

### 計算時間

Maximal Rectanglesはギロチンカットより計算量が多い：

- **ギロチンカット**: O(n log n)
- **Maximal Rectangles**: O(n² × m) ※mは空き矩形の数

**対策**:

- 空き矩形の数を制限（最大100個など）
- 早期終了条件の実装
- Web Workersでバックグラウンド計算

### メモリ使用量

空き矩形のリストが増えるとメモリを消費：

**対策**:

- 定期的な重複削除
- 小さすぎる矩形の除去
- メモリ使用量の監視

---

## 🔄 段階的な移行

### v1.1との共存

v1.2リリース後も、ユーザーが選択できるようにする：

```typescript
// デフォルトはMaximal Rectangles
const algorithm = localStorage.getItem('algorithm') || 'maximal-rectangles'

// ユーザーが切り替え可能
<AlgorithmSelector
  value={algorithm}
  onChange={setAlgorithm}
/>
```

### フォールバック

Maximal Rectanglesが失敗した場合、ギロチンカットにフォールバック：

```typescript
try {
  result = calculateMaximalRectangles(plateConfig, cutConfig, items)
} catch (error) {
  console.warn('Maximal Rectangles failed, falling back to Guillotine')
  result = calculateGuillotine(plateConfig, cutConfig, items)
}
```

---

## 📊 予想される改善効果

### 基本テストプリセットの場合

**現在（v1.0）**:

- 元板枚数: 5枚
- 平均歩留まり: 72%

**予想（v1.2）**:

- 元板枚数: 3-4枚
- 平均歩留まり: 85-90%

---

## 🔗 関連ドキュメント

- [v1.1設計書: ギロチンカット精度向上](./v1.1-design.md)
- [アルゴリズム詳細仕様書](./algorithm-details.md)
- [ロードマップ](../ROADMAP.md)

---

## 📚 参考文献

- [Rectangle Packing Algorithms](https://www.codeproject.com/Articles/210979/Fast-optimizing-rectangle-packing-algorithm-for-bu)
- [Maximal Rectangles Algorithm](http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf)
- [2D Bin Packing Problem](https://en.wikipedia.org/wiki/Bin_packing_problem)
